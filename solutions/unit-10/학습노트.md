# Unit-10 학습노트 - Map/Set 자료구조

## 문제를 처음 봤을 때

Unit-09 DFS가 너무 어려웠어서 이번엔 어떨까 걱정했는데, 훨씬 친절했다. 입력/출력도 명확하고, 힌트에 써야 할 메서드까지 다 알려줬다.

근데 Map이랑 Set이 뭔지 처음 보는 개념이라 막막하긴 했다. "자료구조"라는 말 자체가 좀 어렵게 느껴졌는데, 알고 보니 "데이터를 저장하는 방법"이더라.

## Map 개념 이해하기

Map은 키-값 쌍을 저장하는 상자라고 이해했다.

예를 들어서:
- "사과" → 3개
- "바나나" → 5개
- "딸기" → 2개

이렇게 "이름표 → 값" 형태로 저장하는 거다.

### Map의 주요 메서드

```javascript
const map = new Map();

// 추가하기
map.set("사과", 3);

// 가져오기
map.get("사과");  // 3

// 있는지 확인
map.has("사과");  // true
```

처음엔 왜 객체 안 쓰고 Map을 쓰나 싶었는데, Map이 더 편한 기능들이 많다고 한다. 특히 `size` 속성이나 반복문 돌리기가 쉽다는 점.

### 실전 예제: 숫자 세기

가장 이해하기 쉬웠던 게 "각 숫자가 몇 번 나왔는지 세기"였다.

```javascript
const numbers = [1, 2, 3, 1, 2, 1];
const map = new Map();

for (let num of numbers) {
  if (map.has(num)) {
    const count = map.get(num);
    map.set(num, count + 1);
  } else {
    map.set(num, 1);
  }
}
// 결과: Map { 1 → 3, 2 → 2, 3 → 1 }
```

흐름을 하나씩 따라가면서 이해했다:
1. 1을 봄 → Map에 없음 → `set(1, 1)`
2. 2를 봄 → Map에 없음 → `set(2, 1)`
3. 3을 봄 → Map에 없음 → `set(3, 1)`
4. 1을 또 봄 → Map에 있음 → 기존값(1) +1 → `set(1, 2)`
5. 2를 또 봄 → Map에 있음 → 기존값(1) +1 → `set(2, 2)`
6. 1을 또 봄 → Map에 있음 → 기존값(2) +1 → `set(1, 3)`

머릿속으로 시뮬레이션하니까 완전히 이해됐다.

## Set 개념 이해하기

Set은 중복 없는 값들의 집합이다.

```javascript
const set = new Set();
set.add(1);
set.add(2);
set.add(2);  // 이미 있으면 무시됨
set.add(3);

console.log(set);  // Set {1, 2, 3}
```

2를 두 번 추가했는데도 하나만 들어가 있다. 중복이 자동으로 제거되는 게 핵심이다.

### Set의 주요 메서드

```javascript
set.add(값);      // 추가
set.has(값);      // 확인
set.size;         // 크기
Array.from(set);  // 배열로 변환
```

Map과 비슷하지만, Set은 값만 저장하고 키-값 쌍이 아니라는 게 차이점이다.

## 문제 풀이 과정

### 1. countFrequency - 빈도 계산

가장 기본이 되는 함수였다. 위에서 연습한 것과 똑같은 로직.

처음 코드:
```javascript
function countFrequency(lottoNumbers) {
  const map = new Map();

  for (let num of lottoNumbers) {
    if (map.has(num)) {
      const count = map.get(num);
      map.set(num, count + 1);
    } else {
      map.set(num, 1);
    }
  }

  return map;
}
```

나중에 클린코드로 개선:
```javascript
function countFrequency(lottoNumbers) {
  const map = new Map();

  for (let num of lottoNumbers) {
    const count = map.get(num) || 0;
    map.set(num, count + 1);
  }

  return map;
}
```

`|| 0` 이 부분이 핵심이었다. `map.get(num)`이 `undefined`면 0을 쓰고, 값이 있으면 그 값을 쓴다. if-else 5줄이 2줄로 줄어들었다.

### || 연산자 이해하기

처음엔 `||`가 뭔지 몰랐는데, "왼쪽이 거짓 같으면 오른쪽 값 써"라는 뜻이더라.

JavaScript의 Falsy 값들:
- `undefined`, `null`, `0`, `false`, `""`, `NaN`

```javascript
undefined || 0    // 0
null || "hi"      // "hi"
5 || 10           // 5
```

기본값 설정할 때 진짜 유용한 패턴이다.

### 2. findDuplicates - 중복 찾기

이 문제는 "이미 본 적 있는지" 기억해야 했다.

생각의 흐름:
1. 중복을 어떻게 찾지?
2. 같은 숫자를 두 번 보면 중복이구나
3. "이미 본 숫자들"을 저장할 Set 필요
4. "중복된 숫자들"을 저장할 Set도 필요

```javascript
function findDuplicates(arr) {
  const seen = new Set();        // 이미 본 것들
  const duplicates = new Set();  // 중복된 것들

  for (let num of arr) {
    if (seen.has(num)) {
      duplicates.add(num);  // 이미 봤어 → 중복이야!
    } else {
      seen.add(num);        // 처음 봐 → 기억해둬
    }
  }

  return Array.from(duplicates);
}
```

처음에 if문 빼먹고 코드 짰다가 에러 났었다. for 루프에 else가 바로 올 수는 없다는 걸 배웠다.

### 3. findMostFrequent - 최다 출현 번호

이게 제일 복잡했다. 단계별로 나눠서 생각했다:

1. 빈도 계산 → `countFrequency` 재사용
2. 최댓값 찾기
3. 최댓값과 같은 번호들 모으기
4. 배열로 반환

한 단계씩 쪼개서 보니까 이해됐다.

```javascript
function findMostFrequent(lottoNumbers) {
  // 1단계: 빈도 계산
  const freqMap = countFrequency(lottoNumbers);

  // 2단계: 최댓값 찾기
  const maxCount = Math.max(...freqMap.values());

  // 3단계: 최댓값과 같은 번호들 모으기
  const result = [];
  for (let [num, count] of freqMap.entries()) {
    if (count === maxCount) {
      result.push(num);
    }
  }

  // 4단계: 반환
  return result;
}
```

#### 새로 배운 것들

**`freqMap.values()`**: Map의 값들만 가져온다.
```javascript
Map { 1 → 3, 2 → 2, 3 → 1 }
freqMap.values()  // [3, 2, 1]
```

**`...` (스프레드 연산자)**: 배열을 펼친다.
```javascript
Math.max(...[3, 2, 1])  // Math.max(3, 2, 1)과 같음
```

**`freqMap.entries()`**: Map의 키-값 쌍을 하나씩 꺼낸다.
```javascript
for (let [num, count] of freqMap.entries()) {
  // num: 키, count: 값
}
```

처음엔 `[num, count]` 이 문법이 생소했는데, 구조 분해 할당이라고 하더라.

## 클린코드 개선 과정

테스트는 통과했지만, 코드를 다듬었다.

### 개선 포인트

1. **countFrequency**: if-else → `|| 0` 패턴
2. **들여쓰기**: 일관성 있게 통일
3. **빈 줄**: return 전에 빈 줄 추가해서 가독성 향상

코드 5줄이 2줄로 줄어드니까 훨씬 깔끔해 보였다.

## 배운 점

### Map vs 배열/객체

이번에 Map을 써보면서 언제 뭘 써야 할지 감이 좀 왔다:
- **배열**: 순서 있는 데이터 (0, 1, 2... 인덱스)
- **객체**: 키-값 쌍 (간단한 경우)
- **Map**: 키-값 쌍 + 반복문/크기 필요할 때

### Set의 활용

Set은 "중복 제거"가 핵심이다. 이미 본 건지 체크할 때 진짜 유용했다. `has()` 메서드가 배열의 `includes()`보다 빠르다고 하던데, 나중에 성능 차이도 공부해봐야겠다.

### 작은 단계로 쪼개기

findMostFrequent가 처음엔 복잡해 보였는데, 4단계로 나누니까 이해됐다. 큰 문제를 작은 문제로 쪼개는 게 진짜 중요하다는 걸 다시 느꼈다.

### || 연산자 활용

`|| 0` 패턴이 진짜 유용하다. 기본값 설정할 때 if-else 안 써도 되니까 코드가 훨씬 간결해진다.

## Unit-09와 비교

DFS는 개념 자체가 어려웠는데, 이번 Map/Set은 "문법만 익히면 되는" 문제였다. 난이도는 확실히 Unit-10이 더 쉬웠다.

근데 새로운 걸 배울 수 있어서 좋았다. Map/Set은 앞으로도 자주 쓸 것 같다.
