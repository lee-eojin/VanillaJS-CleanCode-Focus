# Unit-05 학습 노트

## 일반 for문을 쓴 이유

이번엔 Unit-01에서 썼던 `for...of` 대신 일반 `for`문을 사용했다.

```js
// Unit-01에서 사용한 방식
for (const num of arr) {
  total += num;
}

// Unit-05에서 사용한 방식
for (let i = 0; i < answer.length; i++) {
  if (answer[i] === guess[i]) {
    count++;
  }
}
```

이번엔 **인덱스가 필요했다**. 스트라이크는 "같은 위치의 같은 숫자"를 세는 거니까, 0번째는 0번째끼리, 1번째는 1번째끼리 비교해야 한다.

`for...of`는 값만 꺼내오니까 "이게 몇 번째 값인지"를 알 수가 없다. 그래서 인덱스 `i`를 직접 관리하는 일반 for문을 선택했다.

### for문 3단 분해

```js
for (let i = 0; i < answer.length; i++) {
```

이거 한 줄이 처음엔 복잡해 보였는데, 세미콜론 기준으로 3개 부분으로 나뉜다는 걸 알고나니 이해가 쉬웠다.

**1단: `let i = 0`**
시작 인덱스. 배열은 0번부터 시작하니까 0으로 초기화.

**2단: `i < answer.length`**
언제까지 반복할지 조건. `answer.length`가 3이면 `i`가 0, 1, 2일 때만 반복하고 3이 되면 멈춘다. `i <= 2`로 써도 같지만, `length`를 쓰는 게 더 안전하다는 걸 배웠다.

**3단: `i++`**
한 바퀴 돌 때마다 `i`를 1씩 증가. 0 → 1 → 2 → 3(종료)

결국 "0번부터 배열 끝까지, 하나씩 증가하면서" 라는 의미다.

---

## answer.length를 쓴 이유

반복문 조건에서 `DIGIT_COUNT` 대신 `answer.length`를 사용했다.

```js
// 이렇게 쓸 수도 있지만
for (let i = 0; i < DIGIT_COUNT; i++) {

// 이렇게 썼다
for (let i = 0; i < answer.length; i++) {
```

상수 `DIGIT_COUNT`는 "3이어야 한다"는 **규칙**이고, `answer.length`는 **실제 데이터**다.

만약 누군가 실수로 2개짜리 배열을 전달했다고 치면:
- `DIGIT_COUNT` 사용 → 3번 반복 → `answer[2]`가 `undefined`가 됨 (버그 발생)
- `answer.length` 사용 → 2번만 반복 → 실제 데이터 크기만큼만 처리 (안전)

"규칙을 믿지 말고 데이터를 믿어라" 는 말이 이해가 갔다. 함수는 어떤 입력이 들어올지 모르니까, 실제로 들어온 배열 크기에 맞춰 동작하는 게 안전하다.

물론 `DIGIT_COUNT`도 쓸 곳이 있다. 배열을 **만들 때**는 목표 개수니까 상수를 쓰고, 이미 만들어진 배열을 **읽을 때**는 `length`를 쓴다.

---

## answer, guess 라는 이름

파라미터 이름을 `answer`, `guess`로 지었다.

```js
function countStrike(answer, guess) {
  // ...
}
```

처음엔 `arr1`, `arr2` 같은 이름도 생각했는데, 이게 뭘 의미하는지 전혀 모르겠더라. 코드만 봐서는 둘 중 어느 게 정답이고 어느 게 입력값인지 알 수 없다.

숫자 야구 게임 맥락에서 생각해보니 명확했다:
- **answer**: 컴퓨터가 정한 정답 (숨겨진 값)
- **guess**: 사용자가 추측한 값

"Guess the answer" (정답을 맞춰봐) 라는 영어 표현도 자연스럽다. 함수 이름만 봐도 이 게임이 뭐하는 건지 바로 이해된다.

변수명은 단순히 짧게만 짓는 게 아니라, **그 코드가 다루는 영역(도메인)의 용어**를 쓰는 게 중요하다는 걸 배웠다. 게임이면 게임 용어, 쇼핑이면 쇼핑 용어를 쓰는 식으로.

---

## includes() + push() 패턴

중복 없는 랜덤 숫자를 만들 때 `Set` 대신 배열로 구현했다.

```js
function generateRandomDigits() {
  const digits = [];

  while (digits.length < DIGIT_COUNT) {
    const randomNum = Math.floor(Math.random() * MAX_DIGIT) + MIN_DIGIT;

    if (!digits.includes(randomNum)) {
      digits.push(randomNum);
    }
  }

  return digits;
}
```

Unit-04에서는 `Set`을 썼었다. `Set`은 자동으로 중복을 거르니까 편했는데, 이번엔 배열로만 해결해봤다.

**로직:**
1. 랜덤 숫자 하나 뽑기
2. `includes()`로 배열에 이미 있는지 확인
3. 없으면 `push()`로 추가
4. 3개 될 때까지 반복

`!digits.includes(randomNum)`에서 `!`는 "없으면" 이라는 뜻이다.
`includes()`는 있으면 `true`, 없으면 `false`를 반환하는데, `!`로 반대로 뒤집는 거다.

```js
[1, 2].includes(3)   // false (3이 없음)
![1, 2].includes(3)  // true (3이 없으면 참)
```

배열로 하면 `Set`보다 코드가 조금 길지만, `includes()`가 뭘 하는지 명확히 보인다. 둘 다 장단점이 있는 것 같다.

---

## && 연산자로 두 조건 동시 체크

`countBall`에서 볼 판정 조건이 두 개였다.

```js
if (answer.includes(guess[i]) && answer[i] !== guess[i]) {
  count++;
}
```

볼이 되려면:
1. `answer`에 그 숫자가 포함되어 있어야 함
2. 근데 같은 위치는 아니어야 함 (그건 스트라이크니까)

처음엔 if문을 두 번 중첩해서 쓸까 했다.

```js
if (answer.includes(guess[i])) {
  if (answer[i] !== guess[i]) {
    count++;
  }
}
```

근데 이렇게 하니까 들여쓰기가 깊어지고 읽기 불편했다. `&&`를 쓰면 한 줄로 표현할 수 있다.

`&&`는 "그리고" 라는 뜻이다. 왼쪽이 참이면서 **동시에** 오른쪽도 참이어야 전체가 참이 된다.

```js
true && true   // true
true && false  // false
false && true  // false
```

정답 배열 `[1, 2, 3]`에서 추측값 `2`를 확인한다고 치면:
- `answer.includes(2)` → `true` (2가 있음)
- `answer[0] !== 2` → `1 !== 2` → `true` (같은 자리 아님)
- `true && true` → `true` (볼!)

조건이 두 개 이상일 때 `&&`로 연결하면 중첩 if문 없이 깔끔하게 쓸 수 있다는 걸 배웠다.
