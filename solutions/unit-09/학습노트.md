# Unit-09 학습 노트

## DFS/BFS, 진짜 어렵다

이번 Unit에서 멘탈이 좀 흔들렸다. 재귀라는 개념 자체가 머리로는 이해가 가는데 코드로 구현하려니까 막막했다.
"함수가 자기 자신을 호출한다고?" 이게 어떻게 돌아가는 건지 한참 고민했다.

---

## 처음엔 지인에게 물어보면서, 같이 isValid 함수로 분리했었다

```js
function isValid(row, col) {
  return row >= 0 && row < rows &&
         col >= 0 && col < cols &&
         maze[row][col] === 0 &&
         !visited[row][col];
}
```

조건이 너무 길어서 함수로 빼봤다. 더 깔끔해 보였다.

```js
if (isValid(nextRow, nextCol)) {
  if (dfs(nextRow, nextCol)) {
    return true;
  }
}
```

근데 나중에 "이게 내가 혼자서도... 쓸 법한 코드인가?" 생각해보니 아닌 것 같았다. 함수를 너무 많이 쪼개면 오히려 과한 느낌?

그래서 다시 원래대로 돌렸다. 아직은 조건이 길어도 한눈에 보이는 게 나을 수도 있다.

---

## 코드 중복 vs 추상화 고민

DFS와 BFS 함수에서 이런 코드가 중복된다:

```js
const rows = maze.length;
const cols = maze[0].length;
const visited = ...
```

처음엔 "이걸 함수로 빼야 하나?" 고민했다.

```js
function createMazeUtils(maze) {
  return {
    rows: maze.length,
    cols: maze[0].length,
    visited: ...
  };
}
```

지인에게 물어봤더니 "유틸리티 함수로 빼는 게 좋다"고 했다. 근데 실제로 해보니 과한 느낌이었다.

**결론:**
- 3~4줄 중복은 괜찮다
- 함수가 독립적인 게 더 중요
- 10줄 이상 중복이면 그때 함수로 빼자

코테 실전에서는 시간 제약이 빡빡하다. 간단한 게 최고다.

---

## 미로가 뭔지부터 이해 못 했다

README 보고 "2차원 배열로 표현된 미로" 라는 말이 처음엔 와닿지 않았다.

```js
const maze = [
  [0, 0, 1],
  [0, 0, 0],
  [1, 0, 0]
];
```

이게 어떻게 미로인가? 그냥 배열 아닌가? 했는데 격자판으로 그려보니까,

```
(0,0) (0,1) (0,2)
  0     0     1      ← 벽

(1,0) (1,1) (1,2)
  0     0     0

(2,0) (2,1) (2,2)
  1     0     0
       벽
```

`maze[행][열]` 형태로 접근하는 거고, 0은 갈 수 있는 통로, 1은 벽이다. 시작점은 `(0,0)`, 도착점은 `(n-1, m-1)` = 오른쪽 아래 끝.

README에 이런 설명이 없어서 한참 헤맸다. 나중에 그래서 그냥 예시 부분을 수정했다.

---

## 방향 배열이 뭔지 몰랐다

```js
const DIRECTIONS = [[0,1], [1,0], [0,-1], [-1,0]];
```

처음엔 이게 대체 뭐하는 코드인가 싶었다. 그냥 숫자 네 개 묶어놓은 건가?

나중에 알고 보니 상하좌우 이동을 표현하는 거였다.

- `[0, 1]` = 행 변화 없음(0), 열 +1 → 오른쪽
- `[1, 0]` = 행 +1, 열 변화 없음 → 아래
- `[0, -1]` = 행 변화 없음, 열 -1 → 왼쪽
- `[-1, 0]` = 행 -1, 열 변화 없음 → 위

**왜 이렇게 쓰나?**

나중에 for문 돌릴 때 편하다.

```js
for (let i = 0; i < DIRECTIONS.length; i++) {
  const nextRow = row + DIRECTIONS[i][0];
  const nextCol = col + DIRECTIONS[i][1];
}
```

이렇게 하면 상하좌우 4방향을 자동으로 확인할 수 있다. 만약 DIRECTIONS 없이 쓰면:

```js
// 오른쪽 체크
if (isValid(row, col + 1)) { ... }
// 아래 체크
if (isValid(row + 1, col)) { ... }
// 왼쪽 체크
if (isValid(row, col - 1)) { ... }
// 위 체크
if (isValid(row - 1, col)) { ... }
```

코드를 4번 반복해야 한다. 매우 비효율적이다.

---

## 왼쪽/위쪽도 가야 하나?

처음엔 "시작이 왼쪽 위고, 끝이 오른쪽 아래니까 오른쪽/아래만 가면 되는 거 아닌가?" 싶었다.

근데 아니었다. 미로는 막다른 곳에서 **되돌아가야** 한다. (중요하더라)

```
[0, 0, 1]
[1, 1, 0]
[0, 0, 0]
```

이런 경우, 오른쪽/아래만 가면 `(0,2)` 에서 막힌다. `(1,0)`, `(1,1)`이 벽이라서.

올바른 경로는:
```
(0,0) → (0,1) → (0,2)
  ↓               ↓
막힘            (1,2)
                 ↓
              (2,2)
```

또는 돌아가서:
```
(0,0) → (0,1)
  ↓
(1,0) 막힘 → 다시 (0,0)으로
```

막다른 곳에서 되돌아올 때 왼쪽/위쪽이 필요하다. 그래서 4방향 전부 확인해야 한다.

---

## 방문 체크 배열 만들기

```js
const visited = [];
for (let i = 0; i < rows; i++) {
  visited[i] = [];
  for (let j = 0; j < cols; j++) {
    visited[i][j] = false;
  }
}
```

**왜 필요한가?**

같은 곳을 또 방문하면 무한 루프에 빠진다.

```
(0,0) → (0,1) → (0,0) → (0,1) → ...
```

그래서 "여기 이미 갔어!" 표시가 필요하다.

처음엔 전부 `false` (안 감) 으로 초기화한다.

```js
visited = [
  [false, false, false],
  [false, false, false],
  [false, false, false]
]
```

나중에 `(0,0)` 방문하면:

```js
visited[0][0] = true;

visited = [
  [true, false, false],  // (0,0) 방문함!
  [false, false, false],
  [false, false, false]
]
```

이렇게 가는 곳마다 `true`로 바꿔서 표시한다.

---

## 2중 for문이 생소했다

```js
for (let i = 0; i < rows; i++) {
  visited[i] = [];
  for (let j = 0; j < cols; j++) {
    visited[i][j] = false;
  }
}
```

for문 안에 for문이 들어가 있다. 이게 처음엔 헷갈렸다.

**바깥 for문 (i):** 행을 반복
- i = 0 → 0행 처리
- i = 1 → 1행 처리
- i = 2 → 2행 처리

**안쪽 for문 (j):** 각 행의 열을 반복
- j = 0, 1, 2 → 각 열에 `false` 넣기

**실행 순서:**
```js
i=0, j=0 → visited[0][0] = false
i=0, j=1 → visited[0][1] = false
i=0, j=2 → visited[0][2] = false
i=1, j=0 → visited[1][0] = false
i=1, j=1 → visited[1][1] = false
...
```

2차원 배열을 만들 때 이런 패턴을 쓰는구나 싶었다.

---

## DFS 재귀 함수, 제일 어려웠다

```js
function dfs(row, col) {
  if (row === endRow && col === endCol) {
    return true;
  }

  visited[row][col] = true;

  for (let i = 0; i < DIRECTIONS.length; i++) {
    const nextRow = row + DIRECTIONS[i][0];
    const nextCol = col + DIRECTIONS[i][1];

    if (nextRow >= 0 && nextRow < rows &&
        nextCol >= 0 && nextCol < cols &&
        maze[nextRow][nextCol] === 0 &&
        !visited[nextRow][nextCol]) {
      if (dfs(nextRow, nextCol)) {
        return true;
      }
    }
  }

  return false;
}
```

이 코드를 한 줄 한 줄 뜯어보는 데 한참 걸렸다.

---

## 왜 도착 체크를 먼저 하나?

```js
if (row === endRow && col === endCol) {
  return true;
}
```

처음엔 "방문 체크를 먼저 하는 게 순서 아닌가?" 싶었다. 근데 아니었다.

**도착 체크를 먼저 하는 이유:**

1. **효율성** - 도착했으면 바로 끝내면 되니까
2. **명확성** - "도착했나?"가 가장 중요한 질문
3. **1x1 미로** - 시작=끝일 때 깔끔하게 처리

만약 방문 체크를 먼저 하면:
```js
visited[0][0] = true;  // 불필요한 작업
if (도착) return true;
```

도착했는데 visited를 수정하는 건 의미 없다.

---

## 재귀가 정말 어렵다

```js
if (dfs(nextRow, nextCol)) {
  return true;
}
```

**함수가 자기 자신을 호출한다?**

처음엔 이게 어떻게 돌아가는지 상상이 안 됐다.

```js
dfs(0, 0) {
  // (0,0)에서 탐색
  dfs(0, 1) {  // ← 자기를 또 호출!
    // (0,1)에서 탐색
    dfs(1, 1) {  // ← 또 호출!
      // (1,1)에서 탐색
      ...
    }
  }
}
```

마치 미로를 실제로 걸어가는 거랑 비슷하다. 한 칸씩 이동하면서 경로를 찾는다.

**`if (dfs(...))` 로 체크하는 이유:**

`dfs` 함수는 `true` 또는 `false`를 반환한다.
- `true` = 이 방향으로 가니까 도착함!
- `false` = 이 방향은 막다른 길

```js
if (dfs(nextRow, nextCol)) {  // 이 방향으로 가봤더니
  return true;  // 도착했어! 나도 true 반환!
}
// false면 다음 방향 시도
```

---

## 6가지 조건 체크

```js
if (nextRow >= 0 && nextRow < rows &&
    nextCol >= 0 && nextCol < cols &&
    maze[nextRow][nextCol] === 0 &&
    !visited[nextRow][nextCol]) {
```

이 조건문이 제일 길고 복잡했다. 하나씩 뜯어보니 이해됐다.

**1~4번 조건: 미로 안에 있는지**

- `nextRow >= 0` - 위쪽 경계 안
- `nextRow < rows` - 아래쪽 경계 안
- `nextCol >= 0` - 왼쪽 경계 안
- `nextCol < cols` - 오른쪽 경계 안

예를 들어, `(0, 1)` 에서 위로 가려고 하면:
```js
nextRow = 0 - 1 = -1
nextRow >= 0 ? → -1 >= 0 ? → false ❌
// 미로 밖이라 못 감!
```

**5번 조건: 벽이 아닌지**

```js
maze[nextRow][nextCol] === 0
```

- `0` = 통로 (갈 수 있음)
- `1` = 벽 (못 감)

**6번 조건: 아직 방문 안 했는지**

```js
!visited[nextRow][nextCol]
```

`!` = NOT (반대)
- `visited = true` → 방문함 → `!true = false` → 못 감
- `visited = false` → 방문 안 함 → `!false = true` → 갈 수 있음!

**`&&` = 그리고**

6가지 조건이 **전부 true**여야 갈 수 있다. 하나라도 false면 못 간다.

---

## 아직도 재귀가 완벽히 이해 안 됨

솔직히 말하면 아직도 재귀가 머릿속에서 완전히 그려지진 않는다. 코드는 짰지만 "이게 어떻게 돌아가는지" 완벽하게 설명하라면 좀 버벅거릴 것 같다.

재귀는 많이 풀어봐야 익숙해진다고 하던데, 일단 DFS 하나는 구현했으니까 조금은 성장한 것 같다.

BFS는... 더 어려울 것 같은데 일단 도전해보자.

---

