# Unit-03 학습 노트

## 정규표현식이 처음엔 외계어 같았다

이번 문제에서 가장 어려웠던 부분은 정규표현식이었다. `/^\/\/(.)\n(.*)$/` 이걸 처음 봤을 때 진짜 외계어인 줄 알았다. 도대체 이게 뭐지? 슬래시가 왜 이렇게 많지? 괄호는 또 왜 있지? 머리가 복잡해졌다.

일단 차근차근 뜯어보기로 했다. 맨 앞과 맨 뒤의 `/`는 정규표현식의 시작과 끝을 나타내는 구분자라고 한다. 그러니까 실제 패턴은 `^\/\/(.)\n(.*)$` 이 부분이다.

`^`는 문자열의 시작을 의미한다는 건 알겠는데, 그 다음에 나오는 `\/\/`가 헷갈렸다. 왜 `//`가 아니라 `\/\/`일까? 찾아보니까 `/`는 정규표현식에서 구분자로 쓰이기 때문에, 실제 슬래시 문자를 찾으려면 `\`를 앞에 붙여서 이스케이프 해줘야 한다고 한다. 그래서 `\/\/`는 실제로 `//` 두 글자를 찾는다는 의미였다.

그 다음 `(.)`를 봤다. `.`은 아무 글자나 한 글자를 의미한다는 건 알겠는데, 왜 괄호로 감쌌을까? 괄호 `()`는 캡처 그룹이라는 걸 만든다고 한다. 나중에 `match[1]`로 이 부분을 따로 꺼낼 수 있다. 여기서는 사용자가 지정한 구분자 한 글자를 캡처하는 거였다. 그럼 `;`이나 `|` 같은 구분자를 잡아내는 것이었다.

`\n`은 줄바꿈 문자다. 이것도 처음엔 "이게 뭐지?" 싶었는데, 문자열에서 엔터키를 의미한다고 생각하니까 이해가 됐다. 카톡에서 시프트+엔터 치면 줄바꿈 되는 것처럼, HTML에서 `<br>` 태그로 줄바꿈하는 것처럼, 자바스크립트에서는 `\n`으로 표현하는 방식이다.

`(.*)`는 또 다른 캡처 그룹이다. `.`은 아무 글자, `*`는 0개 이상 반복이니까 `.*`는 "아무 글자나 0개 이상"이라는 뜻이다. 결국 나머지 전부를 의미한다. 여기서는 `1;2;3` 같은 숫자 부분을 캡처하는 셈이다.

마지막 `$`는 문자열의 끝을 의미한다. 즉, 전체 패턴을 해석하면 "문자열 시작 + `//` + 구분자 한 글자 + 줄바꿈 + 나머지 전부 + 문자열 끝" 이렇게 되는 거다.

예를 들어 `//;` + 줄바꿈 + `1;2;3` 이런 형식에서 `;`와 `1;2;3` 부분을 각각 추출하는 패턴이다.

```js
const match = text.match(CUSTOM_DELIMITER_PATTERN);
const delimiter = match[1];  // 첫 번째 캡처 그룹 (구분자)
const numbers = match[2];     // 두 번째 캡처 그룹 (숫자들)
```

`match[0]`은 전체 매칭된 문자열이고, `match[1]`은 첫 번째 괄호, `match[2]`는 두 번째 괄호에 잡힌 부분이다. 이제 왜 괄호로 감쌌는지 이해가 됐다. 나중에 따로 꺼내 쓰려고 했던 것이다.

정규표현식은 처음 볼 때 정말 복잡하고 어렵게 느껴졌다. 하지만 각 기호의 의미를 하나씩 이해하고 나니까 전체 패턴이 보이기 시작했다. 여전히 어렵긴 하지만, 외계어는 아니었다. 자주 쓰는 패턴들은 외워두는 게 좋을 것 같다.

## 이스케이프 문자 `\n`의 이해

`\n`이라는 표현이 처음엔 낯설었다. 문자열에서 엔터를 어떻게 표현하지? 그냥 엔터를 치면 되는 거 아닌가? 싶었는데, 코드에서는 `\n`이라는 특수한 문자로 줄바꿈을 표현한다는 걸 알게 됐다.

```js
"//;\n1;2;3"
```

이 문자열을 보면 한 줄처럼 보이지만, 실제로는 두 줄로 이루어진 것처럼 동작한다.
```
//;
1;2;3
```

왜 이렇게 해야 하는 걸까? 생각해보니까 코드에서 문자열은 따옴표로 감싸는데, 중간에 진짜 엔터를 치면 문자열이 끊어져 버린다. 그래서 줄바꿈을 `\n`이라는 문자로 표현하는 방식이었다.

카톡에서 시프트+엔터 치면 줄이 바뀌는 것처럼, HTML에서 `<br>` 태그로 줄바꿈하는 것처럼, 자바스크립트에서는 `\n`으로 표현하는 셈이다. 다만 화면에 보이는 방식이 다를 뿐이다. `\n` 앞부분에는 구분자 정보가 있고, `\n` 뒷부분에는 실제 숫자들이 있다. 이 구조를 이해하고 나니까 왜 정규표현식에서 `\n`을 기준으로 나누는지 명확해졌다.

자바스크립트에서 `\`로 시작하는 문자들을 이스케이프 문자라고 부른다는 것도 알게 됐다. `\n`은 줄바꿈, `\t`는 탭, `\\`는 백슬래시 자체를 의미한다. 처음엔 "왜 이렇게 복잡하게 하지?" 싶었는데, 코드에서 특수한 문자를 표현하려면 이런 방식이 필요했던 것이다. 그냥 엔터를 치면 코드가 깨지니까, `\n`이라는 약속된 표현을 쓰는 셈이다.

## map() 메서드로 배열 변환하기

이번에 `map()`이라는 메서드를 처음 제대로 사용해봤다.

```js
const numbers = tokens.map(toNumber);
```

처음엔 왜 `toNumber()`가 아니라 `toNumber`로 쓰는지 헷갈렸다. 괄호를 붙이면 함수를 바로 실행하는 거고, 괄호 없이 쓰면 함수 자체를 전달하는 거라고 한다. `map()`은 함수를 받아서 배열의 각 요소마다 그 함수를 실행해준다.

그럼 `map()` 없이 for문으로 쓸 수도 있지 않을까? 궁금해서 비교해봤다.

```js
// map 사용
const numbers = tokens.map(toNumber);

// for문 사용
const numbers = [];
for (const token of tokens) {
  numbers.push(toNumber(token));
}
```

둘 다 똑같은 결과를 만들지만, `map()`이 훨씬 간결했다. 그리고 "각 요소를 변환한다"는 의도도 명확하게 드러난다. for문은 뭔가 더 할 것 같은데, map은 딱 변환만 하는 느낌이다.

`map()`은 원본 배열을 건드리지 않고 새로운 배열을 반환한다는 점도 중요했다. `tokens`는 그대로 남아있고, 변환된 결과가 `numbers`에 담긴다. 이런 방식을 불변성을 지킨다고 하는데, 나중에 버그를 줄이는 데 도움이 된다고 한다. 원본이 바뀌면 예상치 못한 곳에서 문제가 생길 수 있으니까.

## 커스텀 구분자 처리 로직

이번 문제의 핵심은 두 가지 모드를 구분하는 것이었다.

1. 커스텀 구분자 모드: `//`로 시작
2. 기본 구분자 모드: 그 외

```js
if (text.startsWith("//")) {
  // 커스텀 구분자 처리
} else {
  // 기본 구분자 처리
}
```

`startsWith()` 메서드로 문자열이 `//`로 시작하는지 확인할 수 있다는 걸 배웠다. 이게 생각보다 간단하고 명확해서 좋았다. `text[0] === '/' && text[1] === '/'` 이렇게 쓸 수도 있겠지만, `startsWith()`가 훨씬 읽기 쉽다.

커스텀 모드에서는 정규표현식으로 구분자와 숫자를 추출하고, 기본 모드에서는 미리 정의한 `DEFAULT_DELIMITER = /,|:/`로 split한다.

```js
if (text.startsWith("//")) {
  const match = text.match(CUSTOM_DELIMITER_PATTERN);
  const delimiter = match[1];
  const numbers = match[2];
  return numbers.split(delimiter);
} else {
  return text.split(DEFAULT_DELIMITER);
}
```

그런데 빈 문자열은 어떻게 처리하지? 빈 문자열도 `startsWith("//")`로 체크하면 false가 나오니까 else로 빠진다. 근데 요구사항에서는 빈 문자열이면 0을 반환해야 한다고 했다. 그래서 맨 처음에 빈 문자열을 체크하는 코드를 추가했다.

```js
if (text === "") {
  return [];
}
```

이렇게 조기 return을 사용하면 나머지 코드가 훨씬 간결해진다. 예외 케이스를 먼저 처리하고, 정상 로직에 집중하는 패턴이다. 만약 이걸 안 하고 else if로 계속 이어가면 코드가 복잡해진다. "이상한 경우는 빨리 return하고, 정상 경우만 남기자"는 생각이 클린 코드의 핵심인 것 같다.

## 매직 넘버를 상수로 정의하기

코드를 작성할 때 `/,|:/` 같은 정규표현식이나 `"invalid number"` 같은 문자열을 직접 쓰지 않고 상수로 정의했다.

```js
const DEFAULT_DELIMITER = /,|:/;
const CUSTOM_DELIMITER_PATTERN = /^\/\/(.)\n(.*)$/;
```

처음엔 "굳이 이렇게까지 해야 하나?" 싶었다. 그냥 코드에 `/,|:/`를 바로 쓰면 되는 거 아닌가? 근데 상수로 정의하니까 좋은 점이 여러 가지였다.

첫째, 의미가 명확해진다. `/,|:/`가 뭔지 바로 안 보이지만 `DEFAULT_DELIMITER`라고 이름 붙이면 "아, 기본 구분자구나" 하고 이해가 된다. 코드를 읽는 사람 입장에서 훨씬 친절하다.

둘째, 나중에 수정할 때 편하다. 만약 구분자 패턴을 바꾸고 싶으면 상수 정의 부분만 수정하면 된다. 코드 여기저기에 `/,|:/`가 흩어져 있으면 다 찾아서 바꿔야 하는데, 상수로 정의하면 한 곳만 바꾸면 끝이다. 실수로 하나를 놓칠 위험도 없다.

셋째, 오타를 방지할 수 있다. `/,|:/`를 여러 번 쓰다 보면 실수로 `/,:/`라고 쓸 수도 있다. 근데 상수는 한 번만 정의하니까 오타 날 일이 없다.

이런 걸 매직 넘버(또는 매직 문자열)를 제거한다고 부른다는 걸 알게 됐다. 코드에 갑자기 나타나는 숫자나 문자열을 "마법같다"고 표현하는 거다. 왜 갑자기 이 값이 나왔는지 모르니까 마법처럼 느껴진다는 의미인 것 같다. 상수로 정의하면 그 값이 왜 필요한지, 어떤 의미인지 명확해진다.

코드의 의도를 명확하게 하고, 유지보수를 쉽게 만드는 중요한 습관인 것 같다. 처음엔 귀찮아 보였는데, 나중을 생각하면 이게 훨씬 낫다.

## 함수를 작게 나누니 테스트하기 쉬웠다

이번 문제를 풀면서 함수를 작게 나눈 게 정말 도움이 됐다.

- `parseTokens()`: 문자열을 토큰 배열로
- `toNumber()`: 문자열을 숫자로
- `sum()`: 숫자 배열을 합으로
- `add()`: 전체 통합

각 함수가 한 가지 일만 하니까, 어디서 문제가 생겼는지 찾기 쉬웠다. 테스트도 각 함수별로 따로 할 수 있어서 디버깅이 훨씬 수월했다. 만약 하나의 큰 함수로 다 처리했다면 어디가 틀렸는지 찾기 어려웠을 것이다.

특히 `add()` 함수가 딱 3줄로 끝난 게 인상적이었다.

```js
function add(text) {
  const tokens = parseTokens(text);
  const numbers = tokens.map(toNumber);
  return sum(numbers);
}
```

각 줄이 하나의 단계를 나타낸다. 문자열 → 토큰 → 숫자 → 합. 흐름이 한눈에 보인다. 주석이 없어도 코드만 읽으면 무슨 일을 하는지 바로 이해된다.

처음엔 "함수가 너무 많아지면 오히려 복잡하지 않나?" 싶었다. 근데 막상 해보니까 반대였다. 작은 함수들을 조합해서 큰 기능을 만드는 방식이 이렇게 깔끔할 수 있다는 걸 배웠다. 각 함수가 이름만 봐도 뭘 하는지 알 수 있어서, 코드를 읽기도 훨씬 쉬웠다.

그리고 재사용도 가능하다. 예를 들어 `sum()` 함수는 다른 곳에서도 쓸 수 있다. 하나의 큰 함수 안에 다 박혀있었다면 불가능했을 것이다. 작게 나누니까 레고 블록처럼 조립할 수 있는 코드가 됐다.
