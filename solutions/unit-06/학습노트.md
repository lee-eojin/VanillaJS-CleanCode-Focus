# Unit-06 학습 노트

## 클린코드 vs 알고리즘 코드 (주관적인 의견)

이번에 "들여쓰기 2단계 이하" 규칙 때문에 버블 정렬을 쪼갤까말까 고민을 상당히 많이했다.

```js
// 함수를 여러개 쪼갠다면 아마도..
function swap(arr, i, j) { ... }
function performBubblePass(arr, passIndex) { ... }
function bubbleSort(arr) { ... }
```

근데 여기서 이렇게 하니까 오히려 복잡해 보였다. 버블 정렬이 뭔지 이해하려면 3개 함수를 왔다갔다 봐야 한다.

**주관적인 생각:**
클린코드 규칙도 맥락에 따라 다르게 적용해야 한다.

- **비즈니스 로직**: 함수 분리가 중요. 각 함수가 하나의 책임만.
- **알고리즘 구현**: 전체 흐름이 한눈에 보이는 게 중요. 교육 목적이면 더더욱.

버블 정렬은 "이중 반복문으로 인접 원소를 비교하는 알고리즘" 을 보여주는 게 목적이다. 이걸 억지로 쪼개면 본질이 흐려진다.

**과도한 추상화는 오히려 독이 될 수 있다.** 코드를 쪼개는 건 이해를 돕기 위함인데, 쪼개서 더 어려워지면 본말전도라고 생각한다.

---

## 버블 정렬의 이중 반복문

이번엔 처음으로 이중 반복문을 써봤다.

```js
for (let i = 0; i < arr.length - 1; i++) {
  for (let j = 0; j < arr.length - 1 - i; j++) {
    if (sorted[j] > sorted[j + 1]) {
      [sorted[j], sorted[j + 1]] = [sorted[j + 1], sorted[j]];
    }
  }
}
```

**바깥 반복문 (i)**: 회전 번호
- 1회전, 2회전, 3회전...
- 매 회전마다 제일 큰 값이 맨 뒤로 이동

**안쪽 반복문 (j)**: 인접한 값 비교
- 0번 vs 1번, 1번 vs 2번...
- 큰 값을 오른쪽으로 밀어냄

구글링을 통해 공부하였는데, 버블 정렬은 "옆 사람이랑 키 비교해서 큰 사람 뒤로" 를 반복하는 것이라는 팁을 생각하니까 쉬웠다.

### arr.length - 1 - i 최적화

안쪽 반복문에서 `arr.length - 1 - i` 를 조건으로 쓴 이유가 있다.

```js
// 1회전 후: 맨 뒤 1개 확정
// 2회전 후: 맨 뒤 2개 확정
// i회전 후: 맨 뒤 i개 확정
```

이미 정렬된 부분은 다시 볼 필요가 없으니까 범위를 줄이는 거다. `-i`를 빼면 불필요한 비교를 줄일 수 있다.

---

## 이진 탐색의 변수 관리

이진 탐색은 `left`, `right`, `mid` 세 변수로 범위를 관리한다.

```js
let left = 0;
let right = sortedArr.length - 1;

while (left <= right) {
  const mid = Math.floor((left + right) / 2);

  if (sortedArr[mid] === target) return mid;

  if (sortedArr[mid] < target) {
    left = mid + 1;
  } else {
    right = mid - 1;
  }
}
```

### left <= right 조건

음 `left < right` 로 쓰게되면 원소가 1개 남았을 때 확인이 불가능하다.

```js
left = 2, right = 2 (원소 1개 남음)
left < right → false (종료) ← 버그!

left <= right → true (확인) ← 정상
```

`<=` 를 써야만이 마지막 원소까지 확인한다.

### mid + 1, mid - 1

중간값을 확인한 후에는 `mid` 자체를 제외해야 한다.

```js
// mid가 target보다 작으면
left = mid + 1;  // mid는 이미 확인했으니 +1

// mid가 target보다 크면
right = mid - 1;  // mid는 이미 확인했으니 -1
```

만약 `left = mid` 로 하면 무한 루프에 빠질 수 있다.

---

## Math.floor가 필요한 이유

중간 인덱스를 구할 때 `Math.floor` 를 쓴다.

```js
const mid = Math.floor((left + right) / 2);
```

인덱스는 정수여야 하는데, 나누기를 하면 소수가 나올 수 있다.

```js
(0 + 3) / 2 = 1.5

arr[1.5] ← 이런 인덱스는 없음!

Math.floor(1.5) = 1 ← 내림
```

`Math.floor`는 소수점을 버리고 정수로 만든다. `Math.ceil` (올림)을 쓰면 범위를 벗어날 수 있으니까 내림이 안전하다.

---

## 조기 return의 중요성

처음 구현할 때 실수로 이렇게 썼었다.

```js
if (sortedArr[mid] < target) {
  left = mid + 1;
} else {
  right = mid - 1;
}
```

찾았을 때 바로 return 하는 조건을 빼먹었다. 테스트를 돌려보니 전부 -1만 반환했다.

```js
if (sortedArr[mid] === target) {
  return mid;  // 찾으면 바로 반환!
}
```

이 한 줄이 없으면 찾아도 계속 범위만 좁히다가 while 문을 빠져나와서 -1을 반환한다.

**조기 return은 불필요한 작업을 막는다.** 찾았으면 더 이상 탐색할 필요가 없으니까 바로 끝내는 거다.

---

## 구조 분해 할당으로 교환

두 값을 교환할 때 구조 분해 할당을 썼다.

```js
[sorted[j], sorted[j + 1]] = [sorted[j + 1], sorted[j]];
```

전통적인 방법은 임시 변수를 쓴다.

```js
const temp = sorted[j];
sorted[j] = sorted[j + 1];
sorted[j + 1] = temp;
```

둘 다 되지만, 구조 분해 할당이 한 줄로 끝나서 깔끔하다. 마치 수학에서 `(a, b) = (b, a)` 하는 느낌이다.

---

## 정렬된 배열의 전제 조건

이진 탐색은 **정렬된 배열**에서만 동작한다는 걸 잊으면 안 된다.

```js
[5, 2, 8, 1]에서 5 찾기
mid = 8
8 > 5 → 왼쪽만 탐색
[5, 2]만 봄 ← 정렬 안 돼서 5를 놓침!
```

정렬이 안 된 배열에서는 "중간값보다 크면 오른쪽" 이라는 논리가 성립하지 않는다. 그래서 이진 탐색 전에 정렬부터 해야 한다.

함수 이름을 `binarySearch(sortedArr, target)` 로 지은 것도 이 전제를 명확히 하기 위해서다. `sortedArr` 라는 이름 자체가 "이미 정렬되어 있어야 한다" 는 힌트를 준다.
