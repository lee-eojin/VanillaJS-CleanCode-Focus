# Unit-07 학습 노트

## var에 관한 고찰

이번 리팩토링 문제에서 가장 먼저 보이게 유도한 것은 역시 `var`를 `const`로 바꾸는 것?

일단 여러가지 직접 테스트해봤다.

```js
console.log(x);  // 뭐가 나올까
var x = 10;
```

결과는 `undefined`였다. 에러가 아니라.

```js
console.log(y);  // 뭐가 나올까
const y = 20;
```

이건 `ReferenceError: Cannot access 'y' before initialization`가 뜬다.

당연히 뭔가 이상하다. 둘 다 선언 전에 접근했는데 왜 결과가 다르지

---

## 호이스팅이라는 개념

책을 통해서 **호이스팅(Hoisting)** 이라는 개념을 자세히 알아보았다.

JavaScript 엔진은 코드를 실행하기 전에 변수 선언을 먼저 처리한다. 선언을 코드 최상단으로 "끌어올린다"는 의미다.

```js
console.log(x);
var x = 10;
```

위 코드는 실제로 이렇게 동작한다:

```js
var x;  // 선언만 위로 올라감
console.log(x);  // undefined (선언은 됐지만 할당 전)
x = 10;  // 할당은 원래 위치에서
```

선언은 호이스팅되지만, 할당은 원래 자리에 남는다. 그래서 `undefined`가 나온 거다.

---

## const/let도 호이스팅이 될까?

여기서 궁금해졌다. `const`/`let`은 호이스팅이 안 되는 걸까?

MDN 문서를 찾아보니, **const/let도 호이스팅된다**고 한다. ????

```js
console.log(y);
const y = 20;
```

---

## TDZ (Temporal Dead Zone)

답은 **TDZ(Temporal Dead Zone)** 에 있었다.

`const`/`let`은 호이스팅은 되지만, 선언 전까지는 "접근 불가능한 영역"에 있다. 이 영역을 TDZ라고 부른다.

```js
// TDZ 시작
console.log(count);  // Error! (TDZ 안에 있음)
const count = 10;  // TDZ 끝
console.log(count);  // 10 (TDZ 빠져나옴)
```

선언문을 만나기 전까지는 변수에 접근할 수 없다. 접근하려고 하면 `ReferenceError`가 발생한다.

반면 `var`는 호이스팅되면서 동시에 `undefined`로 초기화된다. 그래서 선언 전에도 접근이 가능한 거다.

```js
// var는 호이스팅 + undefined 초기화
console.log(x);  // undefined (에러 안 남)
var x = 10;

// const/let은 호이스팅만, 초기화 안 됨
console.log(y);  // Error! (TDZ)
const y = 20;
```

---

## 왜 TDZ가 더 안전할까?

생각해보니, **에러가 나는 게 오히려 좋다**.

```js
// var 사용
console.log(userAge);  // undefined
// ... 100줄
var userAge = 25;
```

위 코드는 에러가 안 나서 버그를 눈치채기 어렵다. `userAge`를 쓰려고 했는데 `undefined`가 나와서 로직이 꼬이는데, 에러도 안 나고 그냥 동작한다.

```js
// const 사용
console.log(userAge);  // Error!
const userAge = 25;
```

이건 바로 에러가 터진다. "선언 전에 쓰지 마" 라고 경고해주는 셈이다. 디버깅하기 훨씬 쉽다.

**실수를 빨리 발견할수록 고치기 쉽다.**

---

## 함수 호이스팅도 있다

변수만 호이스팅되는 게 아니라 함수도 호이스팅된다.

```js
sayHello();  // "Hello!" 출력됨

function sayHello() {
  console.log("Hello!");
}
```

함수 선언문은 **전체가** 호이스팅된다. 선언과 구현이 모두 위로 올라가기 때문에 선언 전에 호출해도 동작한다.

근데 함수 표현식은 다르다.

```js
sayBye();  // Error!

const sayBye = function() {
  console.log("Bye!");
};
```

`const sayBye`는 변수 선언이니까 TDZ 규칙을 따른다. 호이스팅은 되지만 초기화 전까지 접근 불가능.

```js
sayBye();  // undefined is not a function

var sayBye = function() {
  console.log("Bye!");
};
```

`var`로 선언하면 `sayBye`가 `undefined`로 초기화되어서 "함수가 아닌데 호출하려고 했다"는 에러가 난다.

---

## 블록 스코프 vs 함수 스코프

호이스팅 말고도 `var`의 문제가 또 있다.

```js
if (true) {
  var x = 10;
}
console.log(x);  // 10 (???)
```

`var`는 **함수 스코프**라서 블록을 무시한다. `if` 블록 안에서 선언했는데 밖에서도 접근 가능하다.

```js
if (true) {
  const y = 20;
}
console.log(y);  // Error!
```

`const`/`let`은 **블록 스코프**라서 블록 밖에선 접근 불가능하다.

반복문에서 더 큰 문제가 생긴다.

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 3, 3, 3 출력 (예상: 0, 1, 2)
```

`var i`는 반복문 밖에서도 살아있어서 반복이 끝난 후의 값(3)을 참조한다.

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 0, 1, 2 출력
```

`let i`는 각 반복마다 새로운 블록 스코프를 만들어서 각각의 `i` 값을 기억한다.

---

## 그래서 뭘 써야 하나?

결론은 명확하다.

1. **기본은 const**: 재할당이 필요 없으면 `const`
2. **재할당이 필요하면 let**: 반복문 카운터, 누적 값 등
3. **var는 절대 금지**: 레거시 코드에서만 볼 수 있을 뿐

```js
const MAX_COUNT = 100;  // 상수
let count = 0;  // 변할 수 있는 값
```

`const`를 기본으로 쓰면 "이 변수는 바뀌지 않는다"는 의도를 코드로 표현할 수 있다. 나중에 코드를 읽을 때 헷갈리지 않는다.

---

## 리팩토링 전후 비교

### Before
```js
function f(a) {
  var r = [];
  for (var i = 0; i < a.length; i++) {
    if (a[i] % 2 == 0) {
      r.push(a[i]);
    }
  }
  return r;
}
```

**문제점:**
- `var` → 호이스팅으로 인한 혼란, 함수 스코프
- `f`, `a`, `r` → 의미 모호
- 반복문 내 `var i` → 스코프 오염

### After
```js
const EVEN_DIVISOR = 2;

const isEven = (number) => number % EVEN_DIVISOR === 0;

const filterEvenNumbers = (numbers) => numbers.filter(isEven);
```

**개선점:**
- `const` → TDZ로 안전성 확보, 블록 스코프
- 명확한 이름 → 코드가 설명이 됨
- `filter()` → 선언적이고 간결함

호이스팅 때문에 골치 아플 일도 없고, 스코프 오염도 없다. 훨씬 안전하다.
