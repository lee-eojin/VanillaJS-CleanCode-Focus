# Unit-08 학습 노트

## continue로 else if 제거하기

처음 구현할 때 `else if`를 썼었다.

```js
if (isOpeningBracket(char)) {
  stack.push(char);
}
else if (isClosingBracket(char)) {
  // 닫는 괄호 처리
}
```

리팩토링하면서 `continue`로 바꿨다.

```js
if (isOpeningBracket(char)) {
  stack.push(char);
  continue;  
}

if (isClosingBracket(char)) {  // 독립적인 if
  // 닫는 괄호 처리
}
```

`continue`는 "이번 반복 끝내고 다음으로" 라는 뜻이다. 여는 괄호면 스택에 넣고 바로 다음 글자로 넘어간다.

`else if`를 안 쓰니까 두 조건이 독립적으로 보인다. 코드 읽을 때 if문 중첩을 따라갈 필요가 없어서 편했다.

---

## 매직 문자를 상수로 빼기

처음엔 이렇게 썼었다.

```js
if (char === '(' || char === '[' || char === '{') {
  // ...
}
```

`'('`, `'['`, `'{'` 이런 문자들이 여기저기 반복됐다. 이게 매직 문자다.

상수로 정의하니까 훨씬 명확해졌다. 근데 계속 매직 문자 생각하다보니 작명 센스가 매우 중요한거같다. 작명하는것도 요령이 필요한가.

```js
const OPENING_BRACKETS = '([{';
const CLOSING_BRACKETS = ')]}';

function isOpeningBracket(char) {
  return OPENING_BRACKETS.includes(char);
}
```

`includes()`는 문자열이나 배열에서 특정 값이 있는지 확인한다.

```js
'([{'.includes('(')  // true
'([{'.includes(')')  // false
```

만약 나중에 `<>` 같은 괄호를 추가하려면 상수만 바꾸면 된다.

```js
const OPENING_BRACKETS = '([{<';
```

코드 전체를 뒤져서 수정할 필요가 없다.

---

## 복잡한 조건을 함수로 분리

조건문을 함수로 빼니까 읽기 편해졌다.

```js
// Before
if (char === '(' || char === '[' || char === '{') {
  // 여는 괄호냐?를 매번 해석해야 함
}

// After
if (isOpeningBracket(char)) {
  // 함수 이름만 봐도 의도가 명확
}
```

함수 이름이 주석 역할을 한다. `isOpeningBracket`이라는 이름만 봐도 "여는 괄호인지 확인" 이런 느낌인게 바로 보인다.

`isMatchingPair()` 함수도 마찬가지다.

```js
// Before
if (top !== brackets[char]) {
  return false;
}

// After
if (!isMatchingPair(top, char)) {
  return false;
}
```

`brackets[char]`를 직접 비교하는 것보다 "짝이 맞는지" 라는 의도가 더 명확하다.

---

## 함수는 한 가지 일만

`isValidBracket()` 함수는 "괄호가 올바른지 검사"만 한다.

- 여는 괄호 판별 → `isOpeningBracket()`
- 닫는 괄호 판별 → `isClosingBracket()`
- 짝 확인 → `isMatchingPair()`

각 함수가 3줄 이하로 짧다. 테스트하기도 쉽고, 나중에 수정하기도 편하다.

```js
if (isOpeningBracket(char)) {
  stack.push(char);
  continue;
}
```

이 코드만 봐도 무슨 일을 하는지 바로 이해된다.

---

## Stack과 Queue, 왜 클래스로 만들까?

이번엔 처음으로 클래스를 써봤다. 원랜 그냥 함수만 썼는데, 자료구조는 클래스로 만드는 게 더 자연스럽다는 걸 알았다.

```js
// 함수로 만든다면?
function createStack() {
  const items = [];
  return {
    push: (item) => items.push(item),
    pop: () => items.pop(),
    // ...
  };
}

// 클래스로 만들면
class Stack {
  constructor() {
    this.items = [];
  }
  push(item) {
    this.items.push(item);
  }
  pop() {
    return this.items.pop();
  }
}
```

클래스가 더 깔끔해 보인다. `new Stack()` 할 때마다 독립적인 스택이 만들어지고, 각자 자기만의 데이터를 가진다.

---

## this가 뭔지 헷갈렸다

처음에 `this.items = []` 이 부분이 이해가 안 갔다. `this`가 뭘 가리키는 거지? 아니 일단 저게 뭐더라?

```js
const stack1 = new Stack();
stack1.push(1);

const stack2 = new Stack();
stack2.push(99);
```

`stack1`과 `stack2`는 완전히 별개다. 각자 자기만의 `items` 배열을 가진다.

**`this`는 "지금 만들어지는 객체 자신"을 가리킨다.**

- `stack1`을 만들 때: `this` = `stack1`
- `stack2`를 만들 때: `this` = `stack2`

프링글스 통을 여러 개 산다고 생각하면 된다. 각 통은 자기만의 과자 저장 공간이 있다. `this.items`는 "이 통의 저장 공간" 이라는 뜻이다.

---

## Stack은 프링글스, Queue는 줄서기

**Stack (후입선출 - LIFO)**
```js
stack.push(1);  // [1]
stack.push(2);  // [1, 2]
stack.pop();    // 2 (맨 위부터)
```

프링글스 통처럼 위에서 넣고 위에서 뺀다. 나중에 넣은 게 먼저 나온다.

**Queue (선입선출 - FIFO)**
```js
queue.enqueue(1);  // [1]
queue.enqueue(2);  // [1, 2]
queue.dequeue();   // 1 (맨 앞부터)
```

놀이공원 줄서기처럼 뒤에서 들어가고 앞에서 나온다. 먼저 온 사람이 먼저 나간다.

---

## shift()는 처음 들어봤다

Queue를 만들 때 `shift()`라는 메서드를 알게 됐다.

```js
const arr = [1, 2, 3];

arr.push(4);   // 뒤에 추가: [1, 2, 3, 4]
arr.pop();     // 뒤에서 제거: [1, 2, 3]

arr.unshift(0); // 앞에 추가: [0, 1, 2, 3]
arr.shift();    // 앞에서 제거: [1, 2, 3]
```

**배열 메서드 정리:**
- `push()`: 뒤에 추가
- `pop()`: 뒤에서 제거
- `unshift()`: 앞에 추가
- `shift()`: 앞에서 제거

Stack은 `push` + `pop` (뒤에서만 작업)
Queue는 `push` + `shift` (뒤에서 넣고 앞에서 빼기)

---

## 괄호 검사에 Stack을 쓰는 이유

처음엔 "왜 Queue는 안 쓰지?" 싶었다. 근데 직접 생각해보니 이해됐다.

```js
"{[()]}"

1. { → 스택에 넣기
2. [ → 스택에 넣기
3. ( → 스택에 넣기
   Stack: ['{', '[', '(']

4. ) → 스택에서 꺼내기 → '(' 나옴 → 짝 맞음!
   Stack: ['{', '[']
```

**가장 최근에 열린 괄호**가 먼저 닫혀야 한다. 이게 LIFO = Stack이다.

만약 Queue를 쓰면?
```js
Queue: ['{', '[', '(']
) 만나면 맨 앞 '{' 가 나옴 → 짝이 안 맞음!
```

Queue는 먼저 들어온 게 먼저 나오니까 괄호 순서를 제대로 확인할 수 없다.

---

## for...of 복습

문자열을 한 글자씩 읽을 때 `for...of`를 썼다.

```js
for (let char of str) {
  console.log(char);
}
```

Unit-01에서 배웠던 거랑 똑같다. 인덱스가 필요 없을 때는 `for...of`가 간결하다.

```js
// 일반 for문
for (let i = 0; i < str.length; i++) {
  const char = str[i];
}

// for...of (더 간단)
for (let char of str) {
  // 바로 char 사용
}
```

---

## Stack과 Queue의 메서드 이름

Stack과 Queue의 메서드 이름이 다른 이유가 있다.

**Stack:**
- `push()`: 넣기
- `pop()`: 빼기
- `peek()`: 보기

**Queue:**
- `enqueue()`: 넣기 (줄 서기)
- `dequeue()`: 빼기 (줄에서 나가기)
- `front()`: 맨 앞 보기

Queue에서 `push`/`pop`을 안 쓰는 이유는 혼란을 막기 위해서다. 배열의 `push`/`pop`은 뒤에서만 작업하는데, Queue는 뒤에 넣고 앞에서 빼니까.

`enqueue`/`dequeue`라는 이름을 쓰면 "이건 Queue다" 라는 게 명확해진다. 자료구조마다 고유한 용어를 쓰는 게 관례인 것 같다.

---

## 빈 스택/큐 처리

`pop()`이나 `dequeue()`를 빈 상태에서 호출하면 `undefined`를 반환한다.

```js
const stack = new Stack();
stack.pop();  // undefined
```

배열의 `pop()`이 원래 그렇게 동작한다. 에러를 던지지 않고 `undefined`를 반환한다.

```js
[].pop()  // undefined
```

이게 맞는 동작인지는 상황에 따라 다른 것 같다. 에러를 던지는 게 안전할 수도 있지만, 일단 배열의 기본 동작을 따르는 게 예측 가능하다고 판단했다.

---

## 클래스 문법 정리

```js
class Stack {
  constructor() {
    // 객체 만들 때 실행
    this.items = [];
  }

  push(item) {
    // 메서드 (function 키워드 생략)
    this.items.push(item);
  }
}

module.exports = Stack;
```

클래스는 설계도다. `new Stack()`으로 실제 객체를 만든다.

- `constructor`: 객체 초기화 (생성자)
- `this`: 만들어지는 객체 자신
- 메서드: 객체가 할 수 있는 동작

클래스 안에서는 `function` 키워드를 안 쓴다. `push(item) { }` 이렇게만 쓰면 메서드가 된다.
