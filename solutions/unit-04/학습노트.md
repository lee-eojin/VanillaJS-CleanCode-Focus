# Unit-04 학습 노트

## 기본 문제 vs 심화 문제

심화 버전까지 풀었다. 기본 문제만 풀었다면 `randomGenerator` 파라미터 없이 `Math.random()`을 직접 사용하면 된다.

**기본 버전 (Math.random 직접 사용):**
```js
function generateRandomNumber(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function generateLottoNumbers() {
  const numbers = new Set();
  while (numbers.size < 6) {
    const num = generateRandomNumber(1, 45);
    numbers.add(num);
  }
  return Array.from(numbers);
}
```

하지만 그냥 처음부터 `randomGenerator` 골격이 제공되어 있어서 심화 버전으로 진행했다.

## Set을 이용한 중복 제거

이번 문제의 핵심은 중복 없이 6개의 숫자를 뽑는 것이었다. 처음엔 배열에 `includes()`로 중복 체크를 하려고 했는데, Set을 쓰면 훨씬 간단했다.

```js
const numbers = new Set();

while (numbers.size < LOTTO_COUNT) {
  const num = generateRandomNumber(LOTTO_MIN, LOTTO_MAX, randomGenerator);
  numbers.add(num);
}

return Array.from(numbers);
```

Set은 중복을 자동으로 거른다. `add()`로 같은 값을 여러 번 넣어도 하나만 남는다.

```js
const set = new Set();
set.add(5);
set.add(3);
set.add(5);  // 이미 있으니 무시됨
console.log(set);  // Set {5, 3}
```

배열로 했다면 아마도 이렇게 해야 했을 것이다.

```js
const numbers = [];

while (numbers.length < 6) {
  const num = generateRandomNumber(1, 45);
  if (!numbers.includes(num)) {
    numbers.push(num);
  }
}
```

Set을 쓰면 중복 체크 로직이 사라진다. `while (numbers.size < 6)` 조건만으로 끝난다.

## Array.from()으로 Set을 배열로 변환

Set은 배열이 아니라서 인덱스로 접근할 수 없고, `sort()` 같은 배열 메서드도 못 쓴다.

```js
const set = new Set([5, 3, 8]);
console.log(set[0]);  // undefined
console.log(set.length);  // undefined
```

그래서 `Array.from()`으로 배열로 변환했다.

```js
const arr = Array.from(set);
console.log(arr[0]);  // 5
console.log(arr.length);  // 3
```

스프레드 연산자로도 가능하다.

```js
const arr = [...set];
```

둘 다 똑같지만 개인적으로 `Array.from()`이 의도가 더 명확하다고 생각했다.

## 의존성 주입 패턴 - randomGenerator

처음엔 왜 `Math.random()`을 직접 안 쓰고 `randomGenerator`를 파라미터로 받는지 이해가 안 갔다.

```js
function generateRandomNumber(min, max, randomGenerator = defaultRandomGenerator) {
  return randomGenerator.generateNumber(min, max);
}
```

이렇게 하면 더 간단할 것 같았다.

```js
function generateRandomNumber(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
```

하지만 테스트 코드를 보니 이유를 알았다. `Math.random()`은 매번 다른 값을 반환한다. 이걸 어떻게 테스트하나?

```js
test("generateRandomNumber는 1을 반환한다", () => {
  const result = generateRandomNumber(1, 45);
  expect(result).toBe(1);  // 실패! 매번 다른 값이 나옴
});
```

`randomGenerator`를 파라미터로 받으면 테스트할 때 가짜 생성기를 넣을 수 있다.

```js
const fakeGenerator = {
  generateNumber: (min, max) => min  // 항상 최솟값 반환
};

const result = generateRandomNumber(1, 45, fakeGenerator);
expect(result).toBe(1);  // 성공
```

이런 방식을 의존성 주입이라고 한다. 함수가 필요한 것을 외부에서 받아온다. 
테스트할 때는 가짜를 넣고, 실제로 쓸 때는 진짜를 넣는다.

## 기본 파라미터로 선택적 의존성 주입

```js
function generateRandomNumber(min, max, randomGenerator = defaultRandomGenerator) {
  // ...
}
```

`randomGenerator = defaultRandomGenerator` 부분이 기본 파라미터이다.
`randomGenerator`를 안 넘기면 자동으로 `defaultRandomGenerator`가 들어간다.

```js
// 일반 사용 - randomGenerator 안 넘김
generateRandomNumber(1, 45);  // defaultRandomGenerator 사용

// 테스트 - 가짜 생성기 넘김
generateRandomNumber(1, 45, fakeGenerator);  // fakeGenerator 사용
```

이렇게 하면 평소엔 간단하게 쓰고, 필요할 때만 커스터마이징할 수 있다.

## Math.random() 공식 이해하기

`defaultRandomGenerator` 안의 공식이 처음엔 복잡해 보였다.

```js
Math.floor(Math.random() * (max - min + 1)) + min;
```

대충 이해간다. `min=1, max=45`라고 가정하면:

```js
Math.random()              // 0.7382... (0 이상 1 미만)
* (45 - 1 + 1)            // 0.7382 * 45 = 33.219...
Math.floor(...)           // 33 (소수점 버림)
+ 1                       // 34
```

`(max - min + 1)`에서 +1을 하는 이유는 개수 때문이다. 1부터 45까지는 45개다. `45 - 1 = 44`가 아니라 `45 - 1 + 1 = 45`개.

+1을 안 하면 최댓값이 절대 안 나온다.

```js
// +1 없으면
Math.floor(Math.random() * (45 - 1)) + 1;
// 0 ~ 43 + 1 = 1 ~ 44 (45가 안 나옴!)

// +1 있으면
Math.floor(Math.random() * (45 - 1 + 1)) + 1;
// 0 ~ 44 + 1 = 1 ~ 45 (45까지 나옴)
```

## 매직 넘버를 상수로 정의

코드에 1, 45, 6 같은 숫자를 직접 쓰지 않고 상수로 정의했다.

```js
const LOTTO_MIN = 1;
const LOTTO_MAX = 45;
const LOTTO_COUNT = 6;
```

매직 클린을 유도하여 제공하였다. 
숫자를 직접 쓰면 나중에 "이 6이 뭐였지?" 하고 헷갈린다. 상수 이름만 봐도 무슨 의미인지 바로 알 수 있다.

수정을 하려고 해도 편하다. 만약 로또가 7개로 바뀌면 `LOTTO_COUNT`만 바꾸면 된다. 코드 전체를 뒤져서 6을 찾을 필요가 없다.

## while 루프로 조건 만족까지 반복

```js
while (numbers.size < LOTTO_COUNT) {
  const num = generateRandomNumber(LOTTO_MIN, LOTTO_MAX, randomGenerator);
  numbers.add(num);
}
```

for문이 아니라 while문을 쓴 이유는 몇 번을 반복할지 모르기 때문이다.
중복이 나오면 다시 뽑아야 하니까 정확히 6번이 아닐 수 있다.

while문은 "조건을 만족할 때까지" 반복한다. `numbers.size < 6`이 거짓이 되면(= 6개가 되면) 멈춘다.

최악의 경우 운이 나빠서 계속 중복이 나오면 계속 돌 수도 있다. 하지만 Set이 알아서 거르니까 언젠가는 6개가 찬다.

## 함수 하나가 한 가지 일만 하기

`generateLottoNumbers()`는 딱 한 가지만 한다. "중복 없는 6개 숫자 생성". 정렬은 `sortNumbers()`가 따로 한다.

처음엔 `generateLottoNumbers()` 안에서 정렬까지 해버릴까 생각했다. 어차피 정렬된 결과를 원하니까.

```js
function generateLottoNumbers(randomGenerator = defaultRandomGenerator) {
  const numbers = new Set();
  while (numbers.size < LOTTO_COUNT) {
    const num = generateRandomNumber(LOTTO_MIN, LOTTO_MAX, randomGenerator);
    numbers.add(num);
  }
  const arr = Array.from(numbers);
  return arr.sort((a, b) => a - b);  // 여기서 정렬까지?
}
```

하지만 함수를 분리하는 게 맞다. 생성과 정렬은 다른 책임이다. 
나중에 정렬 안 된 로또 번호가 필요할 수도 있고, 다른 방식으로 정렬할 수도 있다.

각 함수가 한 가지 일만 하면 테스트도 쉽고, 재사용도 편하다.
